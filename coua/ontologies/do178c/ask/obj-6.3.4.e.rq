# Source Code is traceable to low-level requirements.
#
# DO-178C does not prescribe a way of doing this. There are two common ways this
# is realized in practise:
#
# Annotate all source code constructs with the requirements that
# they implement. This may not always be a one-to-one mapping, e.g. a collection
# data structure such as a linked list may be used in a variety of different
# contexts to fulfill any number of requirements. This method has the advantage of
# beeing easy to verify by hand, but is hard to maintain by hand.
#
# The second method is to use source code coverage information and annotate test
# cases with requirement IDs. This somewhat indirect approach traces requirements
# via the coverage information generated by the coverage analysis tools to
# individual locations in the source code. If this method is permitted or not
# depends however on the certification agency.
#
# Yet another issue is how to syntacticly define if a location is traced to
# a requirement. It is not practical to annotate each line of source code or
# ranges of source code lines with requirement IDs, since syntactical constructs
# that implement different subsets of requirements may be arbitrarily nested in
# most programming languages. Therefore support from language-specific tooling
# is needed that works by associating spans of source code that identifies a
# syntactical construct, such as individual structs or struct members, with sets
# of requirements. An example of this is the fact that clearly, if in the language
# empty lines are just stripped away by the compiler, they should not require
# requirements tracing.
#
# Therefore it is assumed that all locations that are ingested into the knowledge
# graph correspond to the spans of tracable source code language constructs. It
# is necessary, that all source code locations that are valid source code language
# constructs are present in the knowledge graph.
#
# **Otherwise, this query will readily report that all source code can be traced
# to requirements, even if it is not!**
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX do178c: <https://gitlab.dlr.de/ft-ssy-avs/ap/coua/ontologies/do178c#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
ASK { FILTER NOT EXISTS {
    # Check if this objective is applicable
    do178c:6_3_4_e do178c:hasApplicability ?appl .
    ?appl do178c:toSoftwareLevel ?swl .
    ?sw a do178c:Software ;
        do178c:hasSoftwareLevel ?swl .

    ?LocationClass rdfs:subClassOf+ do178c:Location .
    ?Location a ?LocationClass .
    MINUS {
        ?locationProp rdfs:subPropertyOf+ do178c:location .
        ?TraceClass rdfs:subClassOf+ do178c:TraceData .
        ?rp2 rdfs:subPropertyOf+ do178c:requirementId .
        ?Event a ?TraceClass ;
            ?locationProp ?Location ;
            ?rp2 ?Requirement .
        ?rp1 rdfs:subPropertyOf+ do178c:requirementId .
        ?ReqClass rdfs:subClassOf+ do178c:LowLevelRequirement .
        ?Req a ?ReqClass ;
            ?rp1 ?Requirement .
    }
}}
